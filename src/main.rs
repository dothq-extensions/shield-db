use std::{
    error::Error,
    fs::{self, create_dir, File, remove_dir_all},
    io::Write,
};

use linya::Progress;
use serde::Deserialize;

#[derive(Debug, Deserialize)]
struct ListSource {
    name: String,
    attribution: String,
    license: String,
    sources: Vec<String>
}

#[derive(Debug, Deserialize)]
struct List {
    name: String,
    data: Vec<ListSource>,
}

#[derive(Debug, Deserialize)]
struct Config {
    lists: Vec<List>,
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn Error>> {
    // Read the config file for shieldDB
    let config_str = fs::read_to_string("config.yml")?;
    let config: Config = serde_yaml::from_str(&config_str)?;

    // Log a welcome message
    println!("Dot HQ Blocking Lists");
    println!("===============");

    // Create the out path
    remove_dir_all("out")?;
    create_dir("out")?;

    // Create header template string
    let header_template = format!(
"! This is an automatically generated blocklist based on a number of third-party sources.
! These sources have their own copyright and license. This list was automagically generated by Dot HQ.
! 
! Lists used:
$list_sources$"
    );

    // Create the progress manager
    let mut progress = Progress::new();

    // Loop through all of the lists
    for list_config in &config.lists {
        // Parse the list
        list(list_config, &mut progress, &header_template).await?;
    }

    Ok(())
}

async fn list(
    list: &List,
    progress: &mut Progress,
    header_template: &str,
) -> Result<(), Box<dyn Error>> {
    // Give the name its own separate variable
    let name = &list.name;
    // Create the vec that all of the lists will be added to
    let mut full_list = Vec::new();
    let mut sources: Vec<String> = Vec::new();

    let mut total_sources = 0;

    for source in &list.data {
        for _ in &source.sources {
            total_sources = total_sources + 1;
        }
    }

    // Create a progress bar for this list
    let bar = progress.bar(total_sources, format!("{}", name));

    // Loop through the adblockplus lists
    for list in &list.data {
        // Add source strings
        sources.push(generate_sources_string(list));

        for list_source in &list.sources {
            // Download and parse
            let download = reqwest::get(list_source).await?.text().await?;
            let mut list = parse_abp(download);
            full_list.append(&mut list);

            // Update progress bar
            progress.inc_and_draw(&bar, 1);
        }
    }

    // Sort and dedup for performance
    full_list.sort();
    full_list.dedup();

    // Add header template
    let file_contents = format!(
        "{}\n{}",
        header_template.replace(
            "$list_sources$",
            &sources.join("")
        ),
        full_list.join("\n")
    );

    // Save to the disk
    let mut file = File::create(&format!("{}/{}.txt", "out", name))?;
    file.write_all(&file_contents.as_bytes())?;

    Ok(())
}

fn generate_sources_string(data: &ListSource) -> String {
    format!("!   - {} ({}, {})\n", data.name, data.license, data.attribution)
}

fn parse_abp(file: String) -> Vec<String> {
    file.replace("\r\n", "\n")
        .split('\n')
        .collect::<Vec<&str>>()
        .iter()
        .map(|s| s.split('!').collect::<Vec<&str>>()[0])
        .filter(|s| s != &"")
        .filter(|s| {
            !s.contains('<') && !s.contains(' ') && !s.contains('>') && !s.contains('\u{0009}')
        }) // Why is there html in this list
        .map(|s| s.to_string())
        .collect()
}